## 实时传输网络系统研究

*基于Google WebRTC的实时传输网络,但不局限于WebRTC的网络传输的研究。*


- - -

### 一、基本思想
#### 1. 音视频的传输原则

**经过大量在实际网络环境测试，得出以下结论：**
   - 音频尽量用UDP传输，音频怕延迟和乱序；(OPUS)
   - 视频尽量用TCP传输，视频怕丢包；(H264)

#### 2. 网络流控原则（应用层做流控）

-  设置一定的数值进行传输数量的控制；
-  在时间范围内重新发送数据包；

#### 3. 网络反馈原理及原则

#### 4. 一些算法与策略

##### *(A)基于NACK反馈的丢包重传*
- 接收端(R)循环检测接收缓冲(或者是抖动缓冲)，当发现丢包后，及时发送RTCP NACK将反馈报文的丢包信息反馈给发送端(S); 发送端(S)收到NACK的数据包并解析后从发送缓存取出相对应的RTP包，再次发送给接收端(R)；
- **缺点：**增大了端到端的延迟，尤其是发生大量数据丢包时更为明显；

##### *(B)FEC算法*

 -   **前向纠错**  简称FEC(Forward Error Correction)，其原理是：发送方将要发送的数据附加上一定的冗余纠错码一并发送，接收方则根据纠错码对数据进行差错检测，如发现差错，由接收方进行纠正，特点：使用纠错码（纠错码编码效率低且设备复杂）、单向信道、发送方无需设置缓冲器。
 -   **优点：**视频没有延迟
 -   **缺点：**由于发送数据冗余包占用了额外的网络带宽
 -   参考开源[OPENFEC](http://openfec.org)

##### *(C)拥塞控制与自适应带宽调整*

>拥塞控制技术的提出由来已久，TCP协议栈默认实现了对网络的拥塞控制以保证可靠传输。但在一些场合TCP并不适用，如：无线传输信道，高速长距传输网络、实时通讯应用等。为此，IETF RMCAT（RTP MediaCongestion Avoidance Techniques）工作组提出了一系列针对实时通讯应用的拥塞控制算法需求，包括：能有效控制端到端时延、能有效控制丢包、与其他应用的流共享链路带宽、能够与TCP长连接流公平竞争可用链路带宽等。Google、Cisco和Ericsson等公司相继提出了各自的适用于实时交互应用的拥塞控制算法，开源工程WebRTC的内部实现采用Google提出的算法：Google Congestion Control，简称GCC。

GCC是Google CongestionContrl的缩写，用于实时媒体通讯的网络拥塞控制算法。不是C/C++的编译工具。

GCC基于UDP，它已实现于开源软件WebRTC项目，也集成到M23后的chrome版本，同时应用在GoogleHangouts应用中。
## GCC算法介绍

#### GCC简介
实时媒体通讯的网络拥塞控制有三个难点。

>1.媒体信源不能立刻按要求调整成指定的带宽，通常媒体信源的变化是不连续甚至是跳变的，变化的幅度也大；
2.即使网络拥塞已经被发现，参与的两端也不确定要如何反应，减少带宽不一定是正确的做法；
3.越是压缩率高的编码器越对网络丢包敏感，但网络实时性的要求基本要排除丢包重传的使用。


业界对媒体流的网络拥塞算法已有标准并开放，主要方法是基于速率的控制，通过平滑窗口的算法实现平滑的数据发送，如TFRC(TCP Friendly Rate Control)和RAP(Rate AdaptiveProtocol)。

TCP偏向使用基于丢包率来感知网络拥塞，当网络设备因为拥堵引入队列时，没有丢包但要求实时性的双向媒体传输是不能接受的。另一种是基于时延的方法感知网络拥塞，业界对哪种方案更优一直在争议。


#### 1.基于时延的网络拥塞控制

GCC里基于时延的网络拥塞控制由三部分组成：

>1.到达时间滤波器arrival-timefilter ；
2.过载检查器over-usedetector；
3.速率控制器rate controller。

GCC中使用包间间隔时间为度量，可以是两个网络包间也可以是两组包间的间隔。
 
d(i) = t(i) - t(i-1) - (T(i) - T(i-1))
 
d(i)表示时延，t(i) - t(i-1)是到达时间，T(i) -T(i-1)是发送时间。
 
一列数据包短时间里连续发送，这段时间称为突发时间，建议突发时间为5ms。不建议在突发时间内的包间隔时间做度量，而是把它们做为一组来测量。这种组包发送的形式在WI-FI和无线网络里常常这么用。
 
T(i)用到达包里的时间戳，或一组到达网络包最后一包的时间戳。如到达包有乱序则不采用其数据。
 
当我们把定义发送时间一组长度为L的数据包通过能力为C的通道。
 
ts = L/C于是我们建模有
 
d(i) = dL(i)/C(i) + w(i)
 
  =  dL(i)/C(i) + m(i) + v(i)
 
w(i)是随机函数W的信号量，它的输入因子有吞吐能力C(i)，当前网络阻塞情况，当前速率。在这种模型中我们认为输吞吐能力C比其它参数相对稳定，接近常数或变化缓慢。
 
我们再把w(i)建模成白色高斯过程，于是当对信道过载使用时，w(i)会增加，当信道通过数据量减少时，w(i)会减少，其他情况w(i)为0。
 
从这个模型我们可知，传输的数据量越大所要的时间越长需要相对时延也更大。而网络抖动和其他影响时延的因素不被采集和考虑。
 
因为d(i)和dL(i)是简单可测量的，那么通过w(i)预测C(i)可用一个自适应滤波器来实现，如使用卡尔曼滤波器Kalman filter。

#### 2.卡尔曼滤波

数据滤波是去除噪声还原真实数据的一种数据处理技术。
 
卡尔曼Kalman滤波在测量方差已知的情况下能够从一系列存在测量噪声的数据中，估计动态系统的状态，由于它便于计算机编程实现, 并能够对现场采集的数据进行实时的更新和处理, Kalman滤波是目前应用最为广泛的滤波方法。
 
卡尔曼滤波是一种利用线性系统状态方程，通过系统输入输出观测数据，对系统状态进行最优估计的算法。由于观测数据中包括系统中的噪声和干扰的影响，所以最优估计也可看作是滤波过程。
 
卡尔曼滤波不要求信号和噪声都是平稳过程的假设条件。对于每个时刻的系统扰动和观测误差（即噪声），只要对它们的统计性质作某些适当的假定，通过对含有噪声的观测信号进行处理，就能在平均的意义上，求得误差为最小的真实信号的估计值。
 
假设状态空间的n-1时刻估计值和观测空间的n时刻测量值都满足独立高斯分布，Kalman滤波器就是通过高斯分布的乘积运算将估计值和测量值结合，获得最接近真值的n时刻估计。高斯分布乘积运算的结果仍为高斯分布，高斯分布的均值对应n时刻的估计值，高斯分布的方差对应n时刻的均方误差。

#### 3.过载探测器

d(i) = dL(i)/C(i) + m(i) + v(i)
 
m(i)是从滤波器获取到的预测值，当预测值高于阀值gamma_1(i)则过载探测器发出过载信号给速率控制器。附加条件有这个过载状态需要持续gamma_2毫秒时间。如果m(i)小于m(i-1)，即使高于阀值也不需要发出过载信号。相对应的负数区间也是如此，如m(i)小于-gamma_1(i)时，过载被发现。
 
所以阀值gamma_1对算法的影响很大。如果是gamma_1是静态值会导致一系列问题，所以gamma_1需要动态调整来达到良好的表现。公式如下：
 
   gamma_1(i) = gamma_1(i-1) + (t(i)-t(i-1)) * K(i) * (|m(i)|-gamma_1(i-1))
 
当m(i)超过[-gamma_1(i-1),gamma_1(i-1)]时增加gamma_1(i)，而当m(i)落入[-gamma_1(i-1),gamma_1(i-1)]区间时减少gamma_1(i)。当|m(i)| -gamma_1(i) > 15，建议gamma_1(i)不更新。K(i)为更新系数。
 
同时建议gamma_1(i)控制在[6,600]区间。太小的值会导致探测器过于敏感。建议增加系数要大于减少系数K_u > K_d。
 
其实建议值如下：
 
gamma_1(0) = 12.5 ms
 
gamma_2 = 10 ms
 
K_u = 0.01
 
K_d = 0.00018

#### 4.速率控制器

速率控制器由两个控制器组成，一个是基于时延的预测控制，另一个是基于丢包的的预测控制。控制器内部置状态机，结合过载探测器进行状态的切换。



#### 5.基于丢包的控制

前面介绍基于时延的控制是有一个假设前提，即传输通道的缓冲足够大。当传输通道的缓冲很小时，通过时延是观测不到过载状态的，这时需要丢包率来表示过载。

* 当接收侧感知到2-10%丢包率，发送端的预测值不变。

* 当实际丢包率超过预测值10%时，新的预测值可更新为As_hat(i)= As_hat(i-1)(1-0.5p)，其中p为丢包率。

* 当实际丢包率小于2%时预测时可更新为As_hat(i)= 1.05(As_hat(i-1))，其中p为丢包率。



在GCC中基于丢包的预测值不应大于基于时延的预测，也不应小于基于TFRC（rfc3448）的预测。







- - -


**GCC算法是一种混合了基于丢包和基于时延的方法，原理如下：**

- 发送端根据丢包调整目标带宽，具体来说：低丢包率（小于2%）时增加目标码率，高丢包率（大于10%）时减小目标码率，丢包率介于二者之间时目标码率保持不变；

- 接收端根据时延估计最大带宽，由三个模块组成：排队时延估计、链路过载检测和最大带宽估计模块，三个模块间的关系为：当排队时延小于阈值（根据网络状态自适应调整）时，链路检测结果为underuse；当排队时延大于阈值时，链路检测结果为overuse；介于二者之间时，链路检测结果为normal；最大带宽估计模块的实现是一个表示当前链路状态（Increase、Hold、Decrease）的有限状态机，初始状态为Hold，根据链路检测结果进行状态迁移，并根据迁移后的链路状态和当前接收码率估计最大带宽REMB。

### 二、实际应用

#### 1. WebRTC的网络相关流控和反馈
- WebRTC的相关信息
| 算法   | 代码位置 |
|--------|--------|
| 码率控值|   [webrtc/modules/bitrate_controller]() |
| 拥塞控制 |[webrtc/modules/congestion_controller]()|
| REMB |[webrtc/modules/remote_bitrate_estimator]()|



> 想做一个简单地WebRTC_DEMO 















